<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Optimization of sampling strata with the SamplingStrata package • SamplingStrata</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Optimization of sampling strata with the SamplingStrata package">
<meta property="og:description" content="SamplingStrata">
<meta property="og:image" content="/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-156503236-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-156503236-1');
</script>
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">SamplingStrata</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.5-4</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/SamplingStrata.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/drake_continuous.html">SamplingStrata workflow with drake</a>
    </li>
    <li>
      <a href="../articles/models.html">Use of models in SamplingStrata</a>
    </li>
    <li>
      <a href="../articles/spatial.html">Spatial sampling with SamplingStrata</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/barcaroli/SamplingStrata/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Optimization of sampling strata with the
SamplingStrata package</h1>
                        <h4 data-toc-skip class="author">Marco Ballin,
Giulio Barcaroli</h4>
            
            <h4 data-toc-skip class="date">2023-05-22</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/barcaroli/SamplingStrata/blob/HEAD/vignettes/SamplingStrata.Rmd" class="external-link"><code>vignettes/SamplingStrata.Rmd</code></a></small>
      <div class="hidden name"><code>SamplingStrata.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Let us suppose we need to design a sample survey, having a complete
frame containing information on the target population (identifiers plus
auxiliary information). If our sample design is a stratified one, we
need to choose how to form strata in the population, in order to get the
maximum advantage by the available auxiliary information. In other
words, we have to decide in which way to combine the values of the
auxiliary variables (from now on, the ‘X’ variables) in order to
determine a new variable, called ‘stratum’. To do so, we have to take
into consideration the target variables of our sample survey (from now
on, the ‘Y’ variables): if, to form strata, we choose the X variables
most correlated to the Y’s, the efficiency of the samples drawn by the
resulting stratified frame may be greatly increased. Every combination
of values of each active variable determines a particular stratification
of the target population, i.e.  a possible solution to the problem of
‘best’ stratification. Here, by best stratification, we mean the
stratification that ensures the minimum sample cost, sufficient to
satisfy precision constraints set on the accuracy of the estimates of
the survey target variables Y’s (constraints expressed as maximum
allowable coefficients of variation in the different domains of
interest). When the cost of data collection is uniform over the strata,
then the total cost is directly proportional to the overall sample size,
and the convenience of a particular stratification can be measured by
the associated size of the sample, whose estimates are expected to
satisfy given accuracy levels. This minimum size can be determined by
applying the Bethel algorithm, with its Chromy variant (<span class="citation">Bethel (1989)</span>). In general, the number of
possible alternative stratifications for a given population may be very
high, depending on the number of variables and on the number of their
values, and in these cases it is not possible to enumerate them in order
to assess the best one. A very convenient solution to this is the
adoption of the evolutionary approach, consisting in applying a genetic
algorithm that may converge towards a near-optimal solution after a
finite number of iterations. The methodology is fully described in <span class="citation">M. Ballin and Barcaroli (2013)</span>, and a complete
illustration of the package, together with a comparison with the
<em>stratification</em> package (<span class="citation">Baillargeon and
Rivest (2014)</span>), is in <span class="citation">Barcaroli
(2014)</span>. Also a complete application in a case of network data is
reported in <span class="citation">Marco Ballin and Barcaroli
(2016)</span>. The implementation of the genetic algorithm is based on a
modification of the functions in the <em>genalg</em> package <span class="citation">(see Willighagen 2005)</span>. In particular, the
crossover operator has been modified on the basis of the indications
given by <span class="citation">O’Luing, Prestwich, and Tarim
(2019)</span>.</p>
<p>Two more issues, not contained in this vignette, namely:</p>
<ul>
<li>the use of <em>models</em> to take into account the anticipated
variance of target variables not directly available in the sampling
frame,</li>
<li>the use of SamplingStrata to handle <em>spatial sampling</em>,
i.e. to optimize the stratification of geo-coded sampling frames,</li>
</ul>
<p>are the object of two dedicated vignettes in the section “Articles”
in the website: <a href="https://barcaroli.github.io/SamplingStrata/" class="external-link uri">https://barcaroli.github.io/SamplingStrata/</a> .</p>
</div>
<div class="section level2">
<h2 id="procedural-steps">Procedural steps<a class="anchor" aria-label="anchor" href="#procedural-steps"></a>
</h2>
<p>The optimization of the sampling design starts by making the sampling
frame available, defining the target estimates of the survey and
establishing the precision constraints on them. Then, a choice has to be
made with regard to what stratification variables to choose among those
available in the frame, on the basis of an analysis of the correlation
existing between the two sets of variables (stratification and target).
When the chosen stratification variables are both categorical and
continuous, in order to make them homogeneuous the continuous ones
should be categorized (by using for instance a clustering k-means
algorithm). Then, the optimization step making use of the ‘atomic’
method can be executed. If, conversely, the stratification variables are
all of the continuous type the optimization step can be directly
executed by making use of the method ‘continuous’. It is also possible
to perform both kinds of optimization, compare the results and choose
the more convenient.</p>
<p>Prior to the optimization based on the use of the genetic algorithm,
it is advisable to run a different quick optimization task based on the
use of the k-means algorithm, with a twofold purpose:</p>
<ul>
<li>give a hint on a suitable number of final strata;</li>
<li>get an initial ‘good’ solution to be given as a ‘suggestion’ to the
genetic algorithm in order to speed its convergence to the final
solution.</li>
</ul>
<p>In the optimization step it is possible to indicate the set of
sampling units that must be selected in any case (‘take-all’ strata).
After the optimization, it is possible to evaluate the quality of the
solution by simulating the selection of a high number of samples from
the frame, and calculating sampling variance and bias for all the target
variables. It is also possible to ‘adjust’ the sample size of the
optimized solution on the basis of the available budget: if a higher
size is allowable, sampling rates in strata are increased proportionally
until the new total sample size is reached; the opposite is done in case
we are obliged to reduce the sample size.</p>
<p>Finally, we proceed with the selection of the sample.</p>
<p>In the following, each step will be illustrated starting from a real
sampling frame, the one that comes with the R package <em>sampling</em>
(the dataframe <em>swissmunicipalities</em>).</p>
<div class="section level3">
<h3 id="preparation-of-inputs-required-by-the-optimization-step">Preparation of inputs required by the optimization step<a class="anchor" aria-label="anchor" href="#preparation-of-inputs-required-by-the-optimization-step"></a>
</h3>
<div class="section level4">
<h4 id="frame">Frame<a class="anchor" aria-label="anchor" href="#frame"></a>
</h4>
<p>For sake of simplicity, let us consider a subset of the
<em>swissmunicipalities</em> dataset:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://barcaroli.github.io/SamplingStrata/" class="external-link">SamplingStrata</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">swissmunicipalities</span><span class="op">)</span></span>
<span><span class="va">swissmun</span> <span class="op">&lt;-</span> <span class="va">swissmunicipalities</span><span class="op">[</span><span class="va">swissmunicipalities</span><span class="op">$</span><span class="va">REG</span> <span class="op">&lt;</span> <span class="fl">4</span>,</span>
<span>                                <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"REG"</span>,<span class="st">"COM"</span>,<span class="st">"Nom"</span>,<span class="st">"HApoly"</span>,</span>
<span>                                  <span class="st">"Surfacesbois"</span>,<span class="st">"Surfacescult"</span>,</span>
<span>                                  <span class="st">"Airbat"</span>,<span class="st">"POPTOT"</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">swissmun</span><span class="op">)</span></span>
<span><span class="co">#&gt;    REG  COM       Nom HApoly Surfacesbois Surfacescult Airbat POPTOT</span></span>
<span><span class="co">#&gt; 2    1 6621    Geneve   1593           67           31    773 177964</span></span>
<span><span class="co">#&gt; 3    3 2701     Basel   2391           97           93   1023 166558</span></span>
<span><span class="co">#&gt; 4    2  351      Bern   5162         1726         1041   1070 128634</span></span>
<span><span class="co">#&gt; 5    1 5586  Lausanne   4136         1635          714    856 124914</span></span>
<span><span class="co">#&gt; 9    2  371 Biel (BE)   2123          976          196    463  48655</span></span>
<span><span class="co">#&gt; 10   2  942      Thun   2158          425          694    523  40377</span></span></code></pre></div>
<p>In order to limit the processing time we have selected only the first
3 regions and only the variables of interest for our example. Each row
in this dataset contains information on a swiss municipalities,
identified by <em>COM</em> and <em>Nom</em>, and belonging to one of
three selected regions (<em>REG</em>).</p>
<p>Suppose we want to plan a sampling survey where the <em>target
estimates Ys</em> are the totals of <em>wooded area</em>
(<em>Surfacesbois</em>) and <em>buildings area</em> (<em>Airbat</em>)
for each of the 3 regions (<em>domains of interest</em>). Suppose also
that in each municipalities are always updated the values of <em>total
area</em> (<em>HApoly</em>) and <em>total population</em>
(<em>POPTOT</em>). From the correlation matrix:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html" class="external-link">cor</a></span><span class="op">(</span><span class="va">swissmun</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span><span class="op">:</span><span class="fl">8</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt;                  HApoly Surfacesbois Surfacescult    Airbat     POPTOT</span></span>
<span><span class="co">#&gt; HApoly       1.00000000   0.76920101    0.3398758 0.2602289 0.09940795</span></span>
<span><span class="co">#&gt; Surfacesbois 0.76920101   1.00000000    0.4492188 0.2968918 0.09881328</span></span>
<span><span class="co">#&gt; Surfacescult 0.33987579   0.44921881    1.0000000 0.3230496 0.11451750</span></span>
<span><span class="co">#&gt; Airbat       0.26022890   0.29689183    0.3230496 1.0000000 0.86896631</span></span>
<span><span class="co">#&gt; POPTOT       0.09940795   0.09881328    0.1145175 0.8689663 1.00000000</span></span></code></pre></div>
<p>we see that the correlations between <em>Surfacesbois</em> and
<em>HApoly</em>, from one side, and between <em>Airbat</em> and
<em>POPTOT</em> from the other side, are high (respectively 0.77 and
0.87), so we decide that both <em>HApoly</em> and <em>POPTOT</em> play
the role of <em>stratification variables Xs</em> in our frame.</p>
<p>In a first moment we decide to treat the stratification variables as
categorical, so we have to categorize them. A suitable way to do so, is
to apply a <em>k-means clustering</em> method <span class="citation">(see Hartigan and Wong 1979)</span> by using the
function <em>var.bin</em>:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">swissmun</span><span class="op">$</span><span class="va">HApoly.cat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/var.bin.html">var.bin</a></span><span class="op">(</span><span class="va">swissmun</span><span class="op">$</span><span class="va">HApoly</span>,<span class="fl">15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">swissmun</span><span class="op">$</span><span class="va">HApoly.cat</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15 </span></span>
<span><span class="co">#&gt; 311 345 281 214 158 126 111  84  66  32  29  32  15  11   8</span></span>
<span><span class="va">swissmun</span><span class="op">$</span><span class="va">POPTOT.cat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/var.bin.html">var.bin</a></span><span class="op">(</span><span class="va">swissmun</span><span class="op">$</span><span class="va">POPTOT</span>,<span class="fl">15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">swissmun</span><span class="op">$</span><span class="va">POPTOT.cat</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15 </span></span>
<span><span class="co">#&gt; 452 388 266 193 124 109  79  59  42  33  35  28   5   6   4</span></span></code></pre></div>
<p>We can now define the <em>frame</em> dataframe in the format required
by SamplingStrata. Function <em>buildFrameDF</em> permits to organize
data in a suitable mode for next processing:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">frame1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/buildFrameDF.html">buildFrameDF</a></span><span class="op">(</span>df <span class="op">=</span> <span class="va">swissmun</span>,</span>
<span>                           id <span class="op">=</span> <span class="st">"COM"</span>,</span>
<span>                           X <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"POPTOT.cat"</span>,<span class="st">"HApoly.cat"</span><span class="op">)</span>,</span>
<span>                           Y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Airbat"</span>,<span class="st">"Surfacesbois"</span><span class="op">)</span>,</span>
<span>                           domainvalue <span class="op">=</span> <span class="st">"REG"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">frame1</span><span class="op">)</span></span>
<span><span class="co">#&gt;     id X1 X2   Y1   Y2 domainvalue</span></span>
<span><span class="co">#&gt; 1 6621 15  8  773   67           1</span></span>
<span><span class="co">#&gt; 2 2701 15  9 1023   97           3</span></span>
<span><span class="co">#&gt; 3  351 15 12 1070 1726           2</span></span>
<span><span class="co">#&gt; 4 5586 15 11  856 1635           1</span></span>
<span><span class="co">#&gt; 5  371 14  9  463  976           2</span></span>
<span><span class="co">#&gt; 6  942 14  9  523  425           2</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="strata">Strata<a class="anchor" aria-label="anchor" href="#strata"></a>
</h4>
<p>This dataframe is not explicitly required, as it is automatically
produced from the <em>frame</em> dataframe by the <em>optimStrata</em>
function. Notwithstanding, it is worthwhile to produce it in order to
analyse the initial stratification of the frame, and what could be the
associated sample size without optimization. The function
<em>buildStrataDF</em> is the one to produce the <em>strata</em>
dataframe:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">strata1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/buildStrataDF.html">buildStrataDF</a></span><span class="op">(</span><span class="va">frame1</span>, progress<span class="op">=</span><span class="cn">F</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Computations are being done on population data</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Number of strata:  350</span></span>
<span><span class="co">#&gt; ... of which with only one unit:  130</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">strata1</span><span class="op">)</span></span>
<span><span class="co">#&gt;      STRATO  N        M1         M2        S1        S2 COST CENS DOM1 X1 X2</span></span>
<span><span class="co">#&gt; 1*1     1*1 64  5.359375   34.07812  2.846968  24.54161    1    0    1  1  1</span></span>
<span><span class="co">#&gt; 1*10   1*10  3 17.333333  858.66667 13.299958 264.73928    1    0    1  1 10</span></span>
<span><span class="co">#&gt; 1*11   1*11  3  9.666667  842.00000  1.699673 349.82567    1    0    1  1 11</span></span>
<span><span class="co">#&gt; 1*12   1*12  1  9.000000 1100.00000  0.000000   0.00000    1    0    1  1 12</span></span>
<span><span class="co">#&gt; 1*13   1*13  5 12.200000 1085.40000  3.187475 537.57924    1    0    1  1 13</span></span>
<span><span class="co">#&gt; 1*15   1*15  1 10.000000  387.00000  0.000000   0.00000    1    0    1  1 15</span></span></code></pre></div>
<p>Each row in this dataframe report information related to a given
stratum (obtained by cross-classifying each unit with the values of the
X variables) regarding:</p>
<ul>
<li>the identifier of the stratum (named ‘strato’), concatenation of the
values of the X variables;</li>
<li>the values of the m auxiliary variables (named from X1 to Xm)
corresponding to those in the frame;</li>
<li>the total number of units in the population (named ‘N’);</li>
<li>a flag (named ‘cens’) indicating if the stratum is to be censused
(=1) or sampled (=0);</li>
<li>a variable indicating the cost of interviewing per unit in the
stratum (named ‘cost’);</li>
<li>for each target variable y, its mean and standard deviation, named
respectively ‘Mi’ and ‘Si’);</li>
<li>the value of the domain of interest to which the stratum belongs
(‘DOM1’).</li>
</ul>
</div>
<div class="section level4">
<h4 id="precision-constraints">Precision constraints<a class="anchor" aria-label="anchor" href="#precision-constraints"></a>
</h4>
<p>The <em>errors</em> dataframe contains the accuracy constraints that
are set on target estimates. This means to define a maximum coefficient
of variation for each target variable and for each domain value. Each
row of this frame is related to accuracy constraints in a particular
subdomain of interest, identified by the <em>domainvalue</em> value. In
our case, we have chosen to define the following constraints:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ndom</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="va">swissmun</span><span class="op">$</span><span class="va">REG</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">cv</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>DOM<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="st">"DOM1"</span>,<span class="va">ndom</span><span class="op">)</span>,</span>
<span>                         CV1<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.10</span>,<span class="va">ndom</span><span class="op">)</span>,</span>
<span>                         CV2<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.10</span>,<span class="va">ndom</span><span class="op">)</span>,</span>
<span>                         domainvalue<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">ndom</span><span class="op">)</span> <span class="op">)</span><span class="op">)</span></span>
<span><span class="va">cv</span></span>
<span><span class="co">#&gt;    DOM CV1 CV2 domainvalue</span></span>
<span><span class="co">#&gt; 1 DOM1 0.1 0.1           1</span></span>
<span><span class="co">#&gt; 2 DOM1 0.1 0.1           2</span></span>
<span><span class="co">#&gt; 3 DOM1 0.1 0.1           3</span></span></code></pre></div>
<p>This example reports accuracy constraints (maximum CV allowable equal
to 10%) on variables Y1 and Y2 that are the same for all the 3 different
subdomains (Swiss regions) of domain level DOM1. Of course we can
differentiate the precision constraints region by region. It is
important to underline that the values of ‘domainvalue’ are the same
than those in the <em>frame</em> dataframe, and correspond to the values
of variable ‘DOM1’ in the strata dataframe.</p>
<p>We check that the dataframes that we have defined so far are
correct:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/checkInput.html">checkInput</a></span><span class="op">(</span>errors <span class="op">=</span> <span class="fu"><a href="../reference/checkInput.html">checkInput</a></span><span class="op">(</span>errors <span class="op">=</span> <span class="va">cv</span>, </span>
<span>                               strata <span class="op">=</span> <span class="va">strata1</span>, </span>
<span>                               sampframe <span class="op">=</span> <span class="va">frame1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Input data have been checked and are compliant with requirements</span></span></code></pre></div>
<p>For instance, this function controls that the number of auxiliary
variables is the same in the frame and in the strata dataframes; that
the number of target variables indicated in the frame dataframe is the
same than the number of means and standard deviations in the strata
dataframe, and the same than the number of coefficient of variations
indicated in the errors dataframe.</p>
<p>So far so good. Now we want to determine the total sample size, and
related allocation, under the given strata, using the function
<em>bethel</em> (<span class="citation">Bethel (1989)</span>):</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">allocation</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/bethel.html">bethel</a></span><span class="op">(</span><span class="va">strata1</span>,<span class="va">cv</span><span class="op">[</span><span class="fl">1</span>,<span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">allocation</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 570</span></span></code></pre></div>
<p>This is the total sample size (570) required to satisfy precision
constraints under the current stratification, before the
optimization.</p>
</div>
</div>
<div class="section level3">
<h3 id="optimization">Optimization<a class="anchor" aria-label="anchor" href="#optimization"></a>
</h3>
<p>The function <em>optimStrata</em> is the one performing the
optimization step. Actually, this function is a ‘wrapper’ that calls
three different optimization functions:</p>
<ol style="list-style-type: decimal">
<li>optimizeStrata (method = <em>atomic</em>, if stratification
variables are categorical, or reduced to categorical);</li>
<li>optimizeStrata2 (method = <em>continuous</em>, if stratification
variables are continuous);</li>
<li>optimizeStrataSpatial (method = <em>spatial</em>, if stratification
variables are continuous and there is spatial correlation among units in
a geo-coded sampling frame).</li>
</ol>
<p>For continuity reasons, these functions are still available to be
used standalone, and in some situations it may be useful to use them by
a direct call (see related help for details).</p>
<p>Here we report the most important parameters related to the three
methods (for the others see the help):</p>
<table class="table">
<colgroup>
<col width="14%">
<col width="85%">
</colgroup>
<thead><tr class="header">
<th>Parameter</th>
<th align="left">Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><em>framesamp</em></td>
<td align="left">The name of the dataframe containing the information
related to the</td>
</tr>
<tr class="even">
<td></td>
<td align="left">sampling frame.</td>
</tr>
<tr class="odd">
<td><em>framecens</em></td>
<td align="left">The name of the dataframe containing the units to be
selected in any case.</td>
</tr>
<tr class="even">
<td></td>
<td align="left">It has same structure than “framesamp” dataframe.</td>
</tr>
<tr class="odd">
<td><em>nStrata</em></td>
<td align="left">The number of final optimized strata to be
obtained.</td>
</tr>
<tr class="even">
<td><em>model</em></td>
<td align="left">In case the Y variables are not directly observed, but
are estimated by</td>
</tr>
<tr class="odd">
<td></td>
<td align="left">means of other explicative variables, in order to
compute the anticipated</td>
</tr>
<tr class="even">
<td></td>
<td align="left">variance, information on models are given by a
dataframe “model” with as</td>
</tr>
<tr class="odd">
<td></td>
<td align="left">many rows as the target variables. Default is
NULL.</td>
</tr>
<tr class="even">
<td><em>errors</em></td>
<td align="left">The dataframe containing the precision levels expressed
in</td>
</tr>
<tr class="odd">
<td></td>
<td align="left">terms of maximum allowable coefficient of variation on
a given estimate.</td>
</tr>
<tr class="even">
<td><em>minnumstr</em></td>
<td align="left">Minimum number of units that must be allocated in each
stratum</td>
</tr>
<tr class="odd">
<td></td>
<td align="left">(default is 2).</td>
</tr>
<tr class="even">
<td><em>iter</em></td>
<td align="left">Maximum number of iterations (= generations) of the
genetic algorithm</td>
</tr>
<tr class="odd">
<td></td>
<td align="left">(default is 50).</td>
</tr>
<tr class="even">
<td><em>pops</em></td>
<td align="left">The dimension of each generations in terms of
individuals (default is 20).</td>
</tr>
<tr class="odd">
<td><em>suggestions</em></td>
<td align="left">Optional parameter for genetic algorithm that indicates
a suggested solution</td>
</tr>
<tr class="even">
<td></td>
<td align="left">to be introduced in the initial population. The most
convenient is the</td>
</tr>
<tr class="odd">
<td></td>
<td align="left">one found by the function “KmeanSolution” (default is
NULL).</td>
</tr>
</tbody>
</table>
<div class="section level4">
<h4 id="method-atomic">Method ‘atomic’<a class="anchor" aria-label="anchor" href="#method-atomic"></a>
</h4>
<p>As a first run we execute the optimization step using the method
<em>atomic</em> (required as the stratification variables are of the
categorical type).</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span><span class="va">solution1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/optimStrata.html">optimStrata</a></span><span class="op">(</span>method <span class="op">=</span> <span class="st">"atomic"</span>,</span>
<span>                        errors <span class="op">=</span> <span class="va">cv</span>, </span>
<span>                        nStrata <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">10</span>,<span class="va">ndom</span><span class="op">)</span>,</span>
<span>                        framesamp <span class="op">=</span> <span class="va">frame1</span>,</span>
<span>                        iter <span class="op">=</span> <span class="fl">50</span>,</span>
<span>                        pops <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Input data have been checked and are compliant with requirements</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Computations are being done on population data</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Number of strata:  350</span></span>
<span><span class="co">#&gt; ... of which with only one unit:  130</span></span>
<span><span class="co">#&gt;  *** Starting parallel optimization for  3  domains using  3  cores</span></span></code></pre></div>
<p><img src="SamplingStrata_files/figure-html/optim1-1.png" width="576"><img src="SamplingStrata_files/figure-html/optim1-2.png" width="576"><img src="SamplingStrata_files/figure-html/optim1-3.png" width="576"></p>
<pre><code><span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  *** Sample size :  285</span></span>
<span><span class="co">#&gt;  *** Number of strata :  25</span></span>
<span><span class="co">#&gt; ---------------------------</span></span></code></pre>
<p>The execution of <em>optimStrata</em> produces the solution of 3
different optimization problems, one for each domain. The graphs
illustrate the convergence of the solution to the final one starting
from the initial one (i.e. the one related to the atomic strata). Along
the x-axis are reported the executed iterations, from 1 to the maximum,
while on the y-axis are reported the size of the sample required to
satisfy precision constraints. The upper (red) line represent the
average sample size in each iteration, while the lower (black) line
represents the best solution found until the i-th iteration.</p>
<p>We can calculate (analytically) the expected CVs by executing the
function:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/expected_CV.html">expected_CV</a></span><span class="op">(</span><span class="va">solution1</span><span class="op">$</span><span class="va">aggr_strata</span><span class="op">)</span></span>
<span><span class="co">#&gt;         cv(Y1)    cv(Y2)</span></span>
<span><span class="co">#&gt; DOM1 0.0977868 0.0996821</span></span>
<span><span class="co">#&gt; DOM2 0.1000000 0.1000000</span></span>
<span><span class="co">#&gt; DOM3 0.0997156 0.0990051</span></span></code></pre></div>
<p>The obtained total size of the sample required to satisfy precision
constraint is much lower than the one obtained with the simple
application of the Bethel algorithm to the initial atomic
stratification, but maybe not yet satisfactory.</p>
<p>In order to explore other solutions we may want that each unit in the
sampling frame be considered as an atomic stratum, and let to the
optimization step to aggregate them on the basis of the values of the Y
variables. In any case, as we have to indicate at least one X variable,
we can use to this purpose a simple progressive number:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">swissmun</span><span class="op">$</span><span class="va">progr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">swissmun</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">frame2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/buildFrameDF.html">buildFrameDF</a></span><span class="op">(</span>df <span class="op">=</span> <span class="va">swissmun</span>,</span>
<span>                       id <span class="op">=</span> <span class="st">"COM"</span>,</span>
<span>                       X <span class="op">=</span> <span class="st">"progr"</span>,</span>
<span>                       Y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Airbat"</span>,<span class="st">"Surfacesbois"</span><span class="op">)</span>,</span>
<span>                       domainvalue <span class="op">=</span> <span class="st">"REG"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">frame2</span><span class="op">)</span></span>
<span><span class="co">#&gt;     id X1   Y1   Y2 domainvalue</span></span>
<span><span class="co">#&gt; 1 6621  1  773   67           1</span></span>
<span><span class="co">#&gt; 2 2701  2 1023   97           3</span></span>
<span><span class="co">#&gt; 3  351  3 1070 1726           2</span></span>
<span><span class="co">#&gt; 4 5586  4  856 1635           1</span></span>
<span><span class="co">#&gt; 5  371  5  463  976           2</span></span>
<span><span class="co">#&gt; 6  942  6  523  425           2</span></span></code></pre></div>
<p>We can use this approach because the number of units in the frame is
small: it would not be possible to consider each unit as a stratum in
case of real population registers or even with business registers.</p>
<p>Even so, the processing of the 1,823 strata may be slow.</p>
<p>In order to speed up the convergence towards the optimal solution, an
initial one can be given as a “suggestion” to ‘optimizeStrata’ function.
The function <em>KmeansSolution</em> produces this initial solution by
clustering atomic strata considering the values of the means of all the
target variables Y. For any given number of clusters, the correspondent
aggregation of atomic strata is considered as input to the function
<em>bethel</em>. The number of clusters for which the value of the
sample size necessary to fulfil precision constraints is the minimum
one, is retained as the optimal one. Also, the optimal number of
clusters is determined inside each domain. It is possible to indicate a
maximum number of aggregated strata to be obtained by using the
parameter <em>maxcluster</em>:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">strata2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/buildStrataDF.html">buildStrataDF</a></span><span class="op">(</span><span class="va">frame2</span>, progress<span class="op">=</span><span class="cn">F</span><span class="op">)</span></span>
<span><span class="va">initial_solution2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/KmeansSolution.html">KmeansSolution</a></span><span class="op">(</span>strata <span class="op">=</span> <span class="va">strata2</span>,</span>
<span>                                    errors <span class="op">=</span> <span class="va">cv</span>,</span>
<span>                                    maxclusters <span class="op">=</span> <span class="fl">10</span><span class="op">)</span>  </span></code></pre></div>
<p><img src="SamplingStrata_files/figure-html/initsol-1.png" width="576"><img src="SamplingStrata_files/figure-html/initsol-2.png" width="576"><img src="SamplingStrata_files/figure-html/initsol-3.png" width="576"></p>
<p>The overall solution is obtained by concatenating optimal clusters
obtained in domains. The result is a dataframe with two columns: the
first indicates the clusters, the second the domains. On the basis of
these, we can calculate the most convenient number of final strata for
each domain:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nstrata2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/tapply.html" class="external-link">tapply</a></span><span class="op">(</span><span class="va">initial_solution2</span><span class="op">$</span><span class="va">suggestions</span>,</span>
<span>                 <span class="va">initial_solution2</span><span class="op">$</span><span class="va">domainvalue</span>,</span>
<span>                 FUN<span class="op">=</span><span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">nstrata2</span></span>
<span><span class="co">#&gt;  1  2  3 </span></span>
<span><span class="co">#&gt; 10  8 10</span></span></code></pre></div>
<p>and we can supply both the <em>initial_solution</em> and the number
of strata <em>nstrata</em> as inputs to the optimization step:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span><span class="va">solution2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/optimStrata.html">optimStrata</a></span><span class="op">(</span>method <span class="op">=</span> <span class="st">"atomic"</span>,</span>
<span>                        errors <span class="op">=</span> <span class="va">cv</span>, </span>
<span>                        framesamp <span class="op">=</span> <span class="va">frame2</span>,</span>
<span>                        iter <span class="op">=</span> <span class="fl">50</span>,</span>
<span>                        pops <span class="op">=</span> <span class="fl">10</span>,</span>
<span>                        nStrata <span class="op">=</span> <span class="va">nstrata2</span>,</span>
<span>                        suggestions <span class="op">=</span> <span class="va">initial_solution2</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Input data have been checked and are compliant with requirements</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Computations are being done on population data</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Number of strata:  1823</span></span>
<span><span class="co">#&gt; ... of which with only one unit:  1823</span></span>
<span><span class="co">#&gt;  *** Starting parallel optimization for  3  domains using  3  cores</span></span></code></pre></div>
<p><img src="SamplingStrata_files/figure-html/optim2-1.png" width="576"><img src="SamplingStrata_files/figure-html/optim2-2.png" width="576"><img src="SamplingStrata_files/figure-html/optim2-3.png" width="576"></p>
<pre><code><span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  *** Sample size :  165</span></span>
<span><span class="co">#&gt;  *** Number of strata :  28</span></span>
<span><span class="co">#&gt; ---------------------------</span></span></code></pre>
<p>Notice that the obtained solution in this run in terms of sample size
is significantly better than in the previous one.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">outstrata2</span> <span class="op">&lt;-</span> <span class="va">solution2</span><span class="op">$</span><span class="va">aggr_strata</span></span>
<span><span class="fu"><a href="../reference/expected_CV.html">expected_CV</a></span><span class="op">(</span><span class="va">outstrata2</span><span class="op">)</span></span>
<span><span class="co">#&gt;         cv(Y1)    cv(Y2)</span></span>
<span><span class="co">#&gt; DOM1 0.0994007 0.0301118</span></span>
<span><span class="co">#&gt; DOM2 0.0995359 0.0236793</span></span>
<span><span class="co">#&gt; DOM3 0.0988677 0.0326220</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="method-continuous">Method ‘continuous’<a class="anchor" aria-label="anchor" href="#method-continuous"></a>
</h4>
<p>The last thing to do is to test also the <em>continuous</em>
method.</p>
<p>First, we have to redefine the frame dataframe in this way:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">frame3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/buildFrameDF.html">buildFrameDF</a></span><span class="op">(</span>df <span class="op">=</span> <span class="va">swissmun</span>,</span>
<span>                           id <span class="op">=</span> <span class="st">"COM"</span>,</span>
<span>                           X <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"POPTOT"</span>,<span class="st">"HApoly"</span><span class="op">)</span>,</span>
<span>                           Y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Airbat"</span>,<span class="st">"Surfacesbois"</span><span class="op">)</span>,</span>
<span>                           domainvalue <span class="op">=</span> <span class="st">"REG"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">frame3</span><span class="op">)</span></span>
<span><span class="co">#&gt;     id     X1   X2   Y1   Y2 domainvalue</span></span>
<span><span class="co">#&gt; 1 6621 177964 1593  773   67           1</span></span>
<span><span class="co">#&gt; 2 2701 166558 2391 1023   97           3</span></span>
<span><span class="co">#&gt; 3  351 128634 5162 1070 1726           2</span></span>
<span><span class="co">#&gt; 4 5586 124914 4136  856 1635           1</span></span>
<span><span class="co">#&gt; 5  371  48655 2123  463  976           2</span></span>
<span><span class="co">#&gt; 6  942  40377 2158  523  425           2</span></span></code></pre></div>
<p>Also in this case we want to produce an initial solution:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span><span class="va">init_sol3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/KmeansSolution2.html">KmeansSolution2</a></span><span class="op">(</span>frame<span class="op">=</span><span class="va">frame3</span>,</span>
<span>                             errors<span class="op">=</span><span class="va">cv</span>,</span>
<span>                             maxclusters <span class="op">=</span> <span class="fl">10</span><span class="op">)</span>  </span></code></pre></div>
<p><img src="SamplingStrata_files/figure-html/init_sol3-1.png" width="576"><img src="SamplingStrata_files/figure-html/init_sol3-2.png" width="576"><img src="SamplingStrata_files/figure-html/init_sol3-3.png" width="576"></p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nstrata3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/tapply.html" class="external-link">tapply</a></span><span class="op">(</span><span class="va">init_sol3</span><span class="op">$</span><span class="va">suggestions</span>,</span>
<span>                 <span class="va">init_sol3</span><span class="op">$</span><span class="va">domainvalue</span>,</span>
<span>                 FUN<span class="op">=</span><span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">nstrata3</span></span>
<span><span class="co">#  1  2  3 </span></span>
<span><span class="co"># 10 10  9 </span></span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">initial_solution3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/prepareSuggestion.html">prepareSuggestion</a></span><span class="op">(</span><span class="va">init_sol3</span>,<span class="va">frame3</span>,<span class="va">nstrata3</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Computations are being done on population data</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Number of strata:  29</span></span>
<span><span class="co">#&gt; ... of which with only one unit:  3</span></span></code></pre></div>
<p>Note that this time we call a different function
(<em>KmeansSolution2</em>) that requires, instead of the <em>strata</em>
dataframe, directly the <em>frame</em> dataframe. Moreover, we need an
intermediate step to prepare the suggestion for the optimization, that
is the execution of the function <em>prepareSuggestion</em>.</p>
<p>We are now able to perform the optimization step with the
<em>continuous</em> method:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span><span class="va">solution3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/optimStrata.html">optimStrata</a></span><span class="op">(</span>method <span class="op">=</span> <span class="st">"continuous"</span>,</span>
<span>                        errors <span class="op">=</span> <span class="va">cv</span>, </span>
<span>                        framesamp <span class="op">=</span> <span class="va">frame3</span>,</span>
<span>                        iter <span class="op">=</span> <span class="fl">50</span>,</span>
<span>                        pops <span class="op">=</span> <span class="fl">10</span>,</span>
<span>                        nStrata <span class="op">=</span> <span class="va">nstrata3</span>,</span>
<span>                        suggestions <span class="op">=</span> <span class="va">initial_solution3</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Input data have been checked and are compliant with requirements</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  *** Starting parallel optimization for  3  domains using  3  cores</span></span></code></pre></div>
<p><img src="SamplingStrata_files/figure-html/optim3-1.png" width="576"><img src="SamplingStrata_files/figure-html/optim3-2.png" width="576"><img src="SamplingStrata_files/figure-html/optim3-3.png" width="576"></p>
<pre><code><span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  *** Sample size :  118</span></span>
<span><span class="co">#&gt;  *** Number of strata :  25</span></span>
<span><span class="co">#&gt; ---------------------------</span></span></code></pre>
<p>This solution requires a total sample size that is by far the best
among those we produced, so we decide to select this one.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="analysis-of-the-obtained-solution">Analysis of the obtained solution<a class="anchor" aria-label="anchor" href="#analysis-of-the-obtained-solution"></a>
</h2>
<div class="section level3">
<h3 id="strata-structure">Strata structure<a class="anchor" aria-label="anchor" href="#strata-structure"></a>
</h3>
<p>The results of the execution are contained in the list ‘solution’,
composed by three elements:</p>
<ol style="list-style-type: decimal">
<li>
<em>solution$indices</em>: the vector of the indices that indicates
to what aggregated stratum each atomic stratum belongs (if the
<em>atomic</em> method has been used) or to which aggregated stratum
each unit in the frame belongs (in case the <em>continuous</em> method
has been used);</li>
<li>solution$<em>framenew</em>: the initial frame updated with the
indication, for each unit, of the optimal strata to which each unit
belongs;</li>
<li>
<em>solution$aggr_strata</em>: the dataframe containing information
on the optimized strata.</li>
</ol>
<p>When stratification variables are of the continuous type, and the
<em>continuous</em> (or <em>spatial</em>) method has been used, it is
possible to have detailed information on the structure of the optimized
strata, for instance by using the function <em>summaryStrata</em>:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">strataStructure</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/summaryStrata.html">summaryStrata</a></span><span class="op">(</span><span class="va">solution3</span><span class="op">$</span><span class="va">framenew</span>,</span>
<span>                                 <span class="va">solution3</span><span class="op">$</span><span class="va">aggr_strata</span>,</span>
<span>                                 progress<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">strataStructure</span><span class="op">)</span></span>
<span><span class="co">#&gt;   Domain Stratum Population Allocation SamplingRate Lower_X1 Upper_X1 Lower_X2 Upper_X2</span></span>
<span><span class="co">#&gt; 1      1       1        331         10     0.028723       27     1597       32     1004</span></span>
<span><span class="co">#&gt; 2      1       2         66          5     0.070958      207     6344      107     1126</span></span>
<span><span class="co">#&gt; 3      1       3         40          3     0.073018       99     6804      550     1515</span></span>
<span><span class="co">#&gt; 4      1       4         39          4     0.090954       95     7516      129     2288</span></span>
<span><span class="co">#&gt; 5      1       5         32          4     0.126508      176     8270      436     3384</span></span>
<span><span class="co">#&gt; 6      1       6         30          6     0.192280      130     8892      650     6410</span></span></code></pre></div>
<p>For each otpimized stratum, total number of units together with
allocations and sampling rates are reported. Also ranges of the
stratification variables are listed, in order to characterize the
strata.</p>
<p>If the stratification variables are in a limited number, as in our
case, it is possible to use the <em>plotStrata2d</em> function, that
allows also to visualize strata by choosing couples of variables and one
domain per time:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plotStrata2d.html">plotStrata2d</a></span><span class="op">(</span><span class="va">solution3</span><span class="op">$</span><span class="va">framenew</span>, </span>
<span>             <span class="va">solution3</span><span class="op">$</span><span class="va">aggr_strata</span>,</span>
<span>             domain <span class="op">=</span> <span class="fl">3</span>, </span>
<span>             vars <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"X1"</span>,<span class="st">"X2"</span><span class="op">)</span>,</span>
<span>             labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Total Population"</span>,<span class="st">"Total Area"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<img src="SamplingStrata_files/figure-html/plot2d-1.png" width="576"><table class="table table table-condensed">
<thead><tr>
<th style="text-align:right;">
Stratum
</th>
<th style="text-align:right;">
Population
</th>
<th style="text-align:right;">
Allocation
</th>
<th style="text-align:right;">
SamplingRate
</th>
<th style="text-align:right;">
Bounds Total Population
</th>
<th style="text-align:right;">
Bounds Total Area
</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
37
</td>
<td style="text-align:right;">
2
</td>
<td style="text-align:right;">
0.05405405
</td>
<td style="text-align:right;">
109-3019
</td>
<td style="text-align:right;">
32-241
</td>
</tr>
<tr>
<td style="text-align:right;">
2
</td>
<td style="text-align:right;">
73
</td>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
0.06962653
</td>
<td style="text-align:right;">
112-10429
</td>
<td style="text-align:right;">
244-396
</td>
</tr>
<tr>
<td style="text-align:right;">
3
</td>
<td style="text-align:right;">
90
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
0.11023887
</td>
<td style="text-align:right;">
240-13977
</td>
<td style="text-align:right;">
398-639
</td>
</tr>
<tr>
<td style="text-align:right;">
4
</td>
<td style="text-align:right;">
40
</td>
<td style="text-align:right;">
7
</td>
<td style="text-align:right;">
0.17646223
</td>
<td style="text-align:right;">
235-18323
</td>
<td style="text-align:right;">
651-804
</td>
</tr>
<tr>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
59
</td>
<td style="text-align:right;">
13
</td>
<td style="text-align:right;">
0.21602784
</td>
<td style="text-align:right;">
496-20370
</td>
<td style="text-align:right;">
815-1177
</td>
</tr>
<tr>
<td style="text-align:right;">
6
</td>
<td style="text-align:right;">
21
</td>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
0.24207879
</td>
<td style="text-align:right;">
721-16654
</td>
<td style="text-align:right;">
1184-2029
</td>
</tr>
<tr>
<td style="text-align:right;">
7
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1.00000000
</td>
<td style="text-align:right;">
166558-166558
</td>
<td style="text-align:right;">
2391-2391
</td>
</tr>
</tbody>
</table>
<div class="section level4">
<h4 id="evaluation-by-simulation">Evaluation by simulation<a class="anchor" aria-label="anchor" href="#evaluation-by-simulation"></a>
</h4>
<p>In order to be confident about the quality of the found solution, the
function <em>evalSolution</em> allows to run a simulation, based on the
selection of a desired number of samples from the frame to which the
stratification, identified as the best, has been applied. The user can
invoke this function also indicating the number of samples to be
drawn:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">eval3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/evalSolution.html">evalSolution</a></span><span class="op">(</span>frame <span class="op">=</span> <span class="va">solution3</span><span class="op">$</span><span class="va">framenew</span>, </span>
<span>                     outstrata <span class="op">=</span> <span class="va">solution3</span><span class="op">$</span><span class="va">aggr_strata</span>, </span>
<span>                     nsampl <span class="op">=</span> <span class="fl">200</span>,</span>
<span>                     progress <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> </span>
<span><span class="co">#&gt; Warning in evalSolution(frame = solution3$framenew, outstrata = solution3$aggr_strata, : Folder D:/Google Drive/Sampling/SamplingStrata 1.5/SamplingStrata/vignettes/simulation already existed and has been deleted.</span></span></code></pre></div>
<p>For each drawn sample, the estimates related to the Y’s are
calculated. Their mean and standard deviation are also computed, in
order to produce the CV and relative bias related to each variable in
every domain.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">eval3</span><span class="op">$</span><span class="va">coeff_var</span></span>
<span><span class="co">#&gt;      CV1    CV2  dom</span></span>
<span><span class="co">#&gt; 1 0.0965 0.0972 DOM1</span></span>
<span><span class="co">#&gt; 2 0.0945 0.0970 DOM2</span></span>
<span><span class="co">#&gt; 3 0.0964 0.0510 DOM3</span></span>
<span><span class="va">eval3</span><span class="op">$</span><span class="va">rel_bias</span></span>
<span><span class="co">#&gt;        y1      y2  dom</span></span>
<span><span class="co">#&gt; 1  0.0036  0.0119 DOM1</span></span>
<span><span class="co">#&gt; 2  0.0076 -0.0134 DOM2</span></span>
<span><span class="co">#&gt; 3 -0.0005 -0.0041 DOM3</span></span></code></pre></div>
<p>It is also possible to analyse the sampling distribution of the
estimates for each variable of interest in a selected domain:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dom</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">eval3</span><span class="op">$</span><span class="va">est</span><span class="op">$</span><span class="va">Y1</span><span class="op">[</span><span class="va">eval3</span><span class="op">$</span><span class="va">est</span><span class="op">$</span><span class="va">dom</span> <span class="op">==</span> <span class="va">dom</span><span class="op">]</span>, col <span class="op">=</span> <span class="st">"grey"</span>, border <span class="op">=</span> <span class="st">"white"</span>,</span>
<span>     xlab <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/expression.html" class="external-link">expression</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/influence.measures.html" class="external-link">hat</a></span><span class="op">(</span><span class="va">Y</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>     freq <span class="op">=</span> <span class="cn">FALSE</span>, </span>
<span>     main <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"Variable Y1 Domain "</span>,<span class="va">dom</span>,sep<span class="op">=</span><span class="st">""</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">eval3</span><span class="op">$</span><span class="va">est</span><span class="op">$</span><span class="va">Y1</span><span class="op">[</span><span class="va">eval3</span><span class="op">$</span><span class="va">est</span><span class="op">$</span><span class="va">dom</span> <span class="op">==</span> <span class="va">dom</span><span class="op">]</span><span class="op">)</span>, col <span class="op">=</span> <span class="st">"blue"</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">frame3</span><span class="op">$</span><span class="va">Y1</span><span class="op">[</span><span class="va">frame3</span><span class="op">$</span><span class="va">domainvalue</span><span class="op">==</span><span class="va">dom</span><span class="op">]</span><span class="op">)</span>, col <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">"topright"</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"distribution mean"</span>, <span class="st">"true value"</span><span class="op">)</span>,</span>
<span>       lty <span class="op">=</span> <span class="fl">1</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"blue"</span>, <span class="st">"red"</span><span class="op">)</span>, box.col <span class="op">=</span> <span class="cn">NA</span>, cex <span class="op">=</span> <span class="fl">0.8</span><span class="op">)</span></span></code></pre></div>
<p><img src="SamplingStrata_files/figure-html/distrib-1.png" width="576"></p>
</div>
</div>
<div class="section level3">
<h3 id="adjustment-of-the-final-sampling-size">Adjustment of the final sampling size<a class="anchor" aria-label="anchor" href="#adjustment-of-the-final-sampling-size"></a>
</h3>
<p>After the optimization step, the final sample size is the result of
the allocation of units in final strata. This allocation is such that
the precision constraints are expected to be satisfied. Actually, three
possible situations may occur:</p>
<ul>
<li>the resulting sample size is acceptable;</li>
<li>the resulting sample size is too high, i.e. it is not affordable
with respect to the available budget;</li>
<li>the resulting sample size is too low, the available budget permits
to increase the number of units.</li>
</ul>
<p>In the first case, no action is required. In the second case, it is
necessary to reduce the number of units, by equally applying the same
reduction rate in each stratum. In the third case, we proceed to
increase the sample size by applying the same increase rate in each
stratum. This increase/reduction process is iterative, as by applying
the same rate we could find that in some strata there are not enough
units to increase or to reduce. The function <em>adjustSize</em> permits
to obtain the desired final sample size.</p>
<p>Let us suppose that the final obtained sample size (106) is not
affordable. We can reduce it by executing the following code:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">adjustedStrata</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/adjustSize.html">adjustSize</a></span><span class="op">(</span>size<span class="op">=</span><span class="fl">75</span>,strata<span class="op">=</span><span class="va">solution3</span><span class="op">$</span><span class="va">aggr_strata</span>,cens<span class="op">=</span><span class="cn">NULL</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  79</span></span>
<span><span class="co">#&gt;  79</span></span>
<span><span class="co">#&gt;  Final adjusted size:  79</span></span></code></pre></div>
<p>Instead, if we want to increase the size because the budget allows to
do this, then this is the code:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">adjustedStrata</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/adjustSize.html">adjustSize</a></span><span class="op">(</span>size<span class="op">=</span><span class="fl">150</span>,strata<span class="op">=</span><span class="va">solution3</span><span class="op">$</span><span class="va">aggr_strata</span>,cens<span class="op">=</span><span class="cn">NULL</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  151</span></span>
<span><span class="co">#&gt;  151</span></span>
<span><span class="co">#&gt;  Final adjusted size:  151</span></span></code></pre></div>
<p>The difference between the desired sample size and the actual
adjusted size depends on the number of strata in the optimized solution.
Consider that the adjustment is performed in each stratum by taking into
account the relative difference between the current sample size and the
desired one: this produces an allocation that is expressed by a real
number, that must be rounded, while taking into account the requirement
of the minimum number of units in the strata (default is 2). The higher
the number of strata, the higher the impact on the final adjusted sample
size.</p>
<p>Once increased (or reduced) the sample size we can check what are the
new expected CVs. With the second adjustment, that produced a total
sample size of 152, we obtain:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/expected_CV.html">expected_CV</a></span><span class="op">(</span><span class="va">adjustedStrata</span><span class="op">)</span></span>
<span><span class="co">#      cv(Y1) cv(Y2)</span></span>
<span><span class="co"># DOM1  0.079  0.079</span></span>
<span><span class="co"># DOM2  0.079  0.082</span></span>
<span><span class="co"># DOM3  0.078  0.079</span></span></code></pre></div>
<p>that is, an important reduction of expected CVs.</p>
</div>
<div class="section level3">
<h3 id="sample-selection">Sample selection<a class="anchor" aria-label="anchor" href="#sample-selection"></a>
</h3>
<p>Once the optimal stratification has been obtained, using the function
<em>selectSample</em> it is possible to select the sample from the
optimized version of the frame, taking into account the optimal
stratification and allocation:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">framenew3</span> <span class="op">&lt;-</span> <span class="va">solution3</span><span class="op">$</span><span class="va">framenew</span></span>
<span><span class="va">outstrata3</span> <span class="op">&lt;-</span> <span class="va">solution3</span><span class="op">$</span><span class="va">aggr_strata</span></span>
<span><span class="va">sample</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/selectSample.html">selectSample</a></span><span class="op">(</span><span class="va">framenew3</span>, </span>
<span>                       <span class="va">outstrata3</span>,</span>
<span>                       writeFiles <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; *** Sample has been drawn successfully ***</span></span>
<span><span class="co">#&gt;  118  units have been selected from  25  strata</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; ==&gt; There have been  1  take-all strata </span></span>
<span><span class="co">#&gt; from which have been selected  1 units</span></span></code></pre></div>
<p>When the option <em>writeFiles</em> is set to TRUE, it produces two
.csv files:</p>
<ul>
<li>
<em>sample.csv</em> containing the units of the frame that have been
selected, together with the weight that has been calculated for each one
of them;</li>
<li>
<em>sample.chk.csv</em> containing information on the selection: for
each stratum, the number of units in the population, the planned sample,
the number of selected units, the sum of their weights that must
equalize the number of units in the population.</li>
</ul>
<p>The <em>selectSample</em> function operates by drawing a simple
random sampling in each stratum.</p>
<p>A variant of this function is <em>selectSampleSystematic</em>. The
only difference is in the method used for selecting units in each
strata, that is by executing the following steps:</p>
<ul>
<li>a selection interval is determined by considering the inverse of the
sampling rate in the stratum; a starting point is determined by
selecting a value in this interval;</li>
<li>the selection proceeds by selecting as first unit the one
corresponding to the above value, and then selecting all the units
individuated by adding the selection interval.</li>
</ul>
<p>This selection method can be useful if associated to a particular
ordering of the selection frame, where the ordering variable(s) can be
considered as additional stratum variable(s). For instance, we could
decide that it could be important to consider the <em>industrial
area</em> (<em>Airind</em>) in municipalities when selecting units in
strata. Here is the code:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># adding POPTOT to framenew</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"swissmunicipalities"</span><span class="op">)</span></span>
<span><span class="va">framenew</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sp/man/merge.html" class="external-link">merge</a></span><span class="op">(</span><span class="va">solution3</span><span class="op">$</span><span class="va">framenew</span>,</span>
<span>                  <span class="va">swissmunicipalities</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"COM"</span>,<span class="st">"Airind"</span><span class="op">)</span><span class="op">]</span>,</span>
<span>                  by.x<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"ID"</span><span class="op">)</span>,by.y<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"COM"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># selection of sample with systematic method</span></span>
<span><span class="va">sample</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/selectSampleSystematic.html">selectSampleSystematic</a></span><span class="op">(</span>frame<span class="op">=</span><span class="va">framenew</span>,</span>
<span>                                 outstrata<span class="op">=</span><span class="va">solution3</span><span class="op">$</span><span class="va">aggr_strata</span>,</span>
<span>                                 sortvariable <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Airind"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; *** Sample has been drawn successfully ***</span></span>
<span><span class="co">#&gt;  118  units have been selected from  25  strata</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; ==&gt; There have been  1  take-all strata </span></span>
<span><span class="co">#&gt; from which have been selected  1 units</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="handling-take-all-strata">Handling ‘take-all’ strata<a class="anchor" aria-label="anchor" href="#handling-take-all-strata"></a>
</h3>
<p>As input to the optimization step, together with proper sampling
strata, it is also possible to provide take-all strata. These strata
will not be subject to optimization as the proper strata, but they will
contribute to the determination of the best stratification, as their
presence in a given domain will permit to satisfy precision constraint
with a lower number of units belonging to proper sampling strata.</p>
<p>In order to correctly execute the optimization and further steps, it
is necessary to perform a pre-processing of the overall input. The first
step to be executed consists in the bi-partition of units to be censused
and of units to be sampled, in order to build two different frames. As
an example, we want to be sure that all municipalities whose total
population is higher than 10,000 will be always included in the sample.
So, we partition the sampling frame in this way:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#----Selection of units to be censused from the frame</span></span>
<span><span class="va">ind_framecens</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="va">frame3</span><span class="op">$</span><span class="va">X1</span> <span class="op">&gt;</span> <span class="fl">10000</span><span class="op">)</span></span>
<span><span class="va">framecens</span> <span class="op">&lt;-</span> <span class="va">frame3</span><span class="op">[</span><span class="va">ind_framecens</span>,<span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">framecens</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 63</span></span>
<span><span class="co">#----Selection of units to be sampled from the frame</span></span>
<span><span class="co"># (complement to the previous)</span></span>
<span><span class="va">framesamp</span> <span class="op">&lt;-</span> <span class="va">frame3</span><span class="op">[</span><span class="op">-</span><span class="va">ind_framecens</span>,<span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">framesamp</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 1760</span></span></code></pre></div>
<p>In this way, we have defined as to be censused all units with
population greater than 10,000 (63). At the end of the process, the
sample will contain all these units.</p>
<p>We now run the optimization step by including the indication of to be
censused units:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span><span class="va">solution4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/optimStrata.html">optimStrata</a></span><span class="op">(</span>method <span class="op">=</span> <span class="st">"continuous"</span>,</span>
<span>                        errors <span class="op">=</span> <span class="va">cv</span>, </span>
<span>                        framesamp <span class="op">=</span> <span class="va">framesamp</span>,</span>
<span>                        framecens <span class="op">=</span> <span class="va">framecens</span>,</span>
<span>                        iter <span class="op">=</span> <span class="fl">50</span>,</span>
<span>                        pops <span class="op">=</span> <span class="fl">10</span>,</span>
<span>                        nStrata <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="fl">10</span>,<span class="fl">10</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Input data have been checked and are compliant with requirements</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Input data have been checked and are compliant with requirements</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  *** Starting parallel optimization for  3  domains using  3  cores</span></span></code></pre></div>
<p><img src="SamplingStrata_files/figure-html/optim4-1.png" width="576"><img src="SamplingStrata_files/figure-html/optim4-2.png" width="576"><img src="SamplingStrata_files/figure-html/optim4-3.png" width="576"></p>
<pre><code><span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;  *** Sample size :  71</span></span>
<span><span class="co">#&gt;  *** Number of strata :  27</span></span>
<span><span class="co">#&gt; ---------------------------</span></span></code></pre>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">framenew4</span> <span class="op">&lt;-</span> <span class="va">solution4</span><span class="op">$</span><span class="va">framenew</span></span>
<span><span class="va">outstrata4</span> <span class="op">&lt;-</span> <span class="va">solution4</span><span class="op">$</span><span class="va">aggr_strata</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">outstrata4</span><span class="op">$</span><span class="va">SOLUZ</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 134.2646</span></span>
<span><span class="fu"><a href="../reference/expected_CV.html">expected_CV</a></span><span class="op">(</span><span class="va">outstrata4</span><span class="op">)</span></span>
<span><span class="co">#&gt;         cv(Y1)    cv(Y2)</span></span>
<span><span class="co">#&gt; DOM1 0.0997170 0.0988762</span></span>
<span><span class="co">#&gt; DOM2 0.0971781 0.0971369</span></span>
<span><span class="co">#&gt; DOM3 0.0887425 0.0902738</span></span></code></pre></div>
<p>Once the optimized solution has been produced, we select the
sample:</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sample</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/selectSample.html">selectSample</a></span><span class="op">(</span>frame<span class="op">=</span><span class="va">framenew4</span>,</span>
<span>                       outstrata<span class="op">=</span><span class="va">outstrata4</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; *** Sample has been drawn successfully ***</span></span>
<span><span class="co">#&gt;  134  units have been selected from  30  strata</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; ==&gt; There have been  3  take-all strata </span></span>
<span><span class="co">#&gt; from which have been selected  63 units</span></span></code></pre></div>
<p>and we control that all take-all units are included in the
sample:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">framecens</span><span class="op">$</span><span class="va">id</span> <span class="op"><a href="https://rdrr.io/r/base/match.html" class="external-link">%in%</a></span> <span class="va">sample</span><span class="op">$</span><span class="va">ID</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 63</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="appendix---methodological-approach">Appendix - Methodological approach<a class="anchor" aria-label="anchor" href="#appendix---methodological-approach"></a>
</h2>
<p>In a stratified sampling design with one or more stages, a sample is
selected from a frame containing the units of the population of
interest, stratified according to the values of one or more auxiliary
variables (X) available for all units in the population.</p>
<p>For a given stratification, the overall size of the sample and the
allocation in the different strata can be determined on the basis of
constraints placed on the expected accuracy of the various estimates
regarding the survey variables (Y).</p>
<p>If the target survey variables are more than one the optimization
problem is said to be <em>multivariate</em>; otherwise it is
<em>univariate</em>.</p>
<p>For a given stratification, in the univariate case the optimization
of the allocation is in general based on the <em>Neyman allocation</em>.
In the univariate case it is possible to make use of the <em>Bethel
algorithm</em>.</p>
<p>The criteria according to which stratification is defined are crucial
for the efficiency of the sample.</p>
<p>With the same precision constraints, the overall size of the sample
required to satisfy them may be significantly affected by the particular
stratification chosen for the population of interest.</p>
<p>Given G survey variables, their sampling variance is:</p>
<p><span class="math display">\[Var(\hat{Y_{g}})=\sum_{h=1}^{H}N_{h}^{2}
(1- \frac{
  n_{h}}
  {N_{h}}) \frac{
  S_{h,g}^{2}}
  {n_{h}} \;\;\;  g=1,...,G\]</span></p>
<p>If we introduce the following cost function:</p>
<p><span class="math display">\[C(n_{1},...,n_{H})=C_{0}+\sum_{h=1}^{H}C_{h}n_{h}
\]</span></p>
<p>the optimization problem can be formalized in this way:</p>
<p><span class="math display">\[min= C_{0}+\sum_{h=1}^{H}C_{h}n_{h}\\
\]</span> under the constraints <span class="math display">\[
\begin{cases}
CV(\hat{Y_{1}}) &lt; U_{1}\\
CV(\hat{Y_{2}}) &lt; U_{2}\\
...\\
CV(\hat{Y_{G}}) &lt; U_{G}\\
\end{cases}
\]</span> where <span class="math display">\[ CV(\hat{Y_{g}}) =
\frac{\sqrt{Var(\hat{Y_{g}})} } {mean(\hat{Y_{g}})}\]</span></p>
<p>Given a population frame with m auxiliary variables <span class="math inline">\(X_{1},..., X_{M}\)</span> we define as <em>atomic
stratification</em> the one that can be obtained considering the
cartesian product of the definition domains of the m variables. <span class="math display">\[L=\{(l_{1}),(l_{2}),...,(l_{k})\}\]</span>
Starting from the atomic stratification, it is possible to generate all
the different stratifications that belong to the universe of
stratifications. For example:</p>
<p><span class="math display">\[
\begin{align*}
&amp;P_{1}=\{(l_{1},l_{2},l_{3})\} &amp; P_{2}=\{(l_{1}),(l_{2},l_{3})\}
\\
&amp;P_{2}=\{(l_{2}),(l_{1},l_{3})\} &amp;
P_{4}=\{(l_{31}),(l_{1},l_{2})\} \\
&amp;P_{5}=\{(l_{1}),(l_{2}),(l_{k})\}
\end{align*}
\]</span></p>
<p>The number of feasible stratifications is exponential with respect to
the number of initial atomic strata:</p>
<p><span class="math display">\[
\begin{align*}
&amp; B_{4}=15 &amp; B_{10}=115975 &amp;
&amp; B_{100}\approx 4.76 \times 10^{115}
\end{align*}
\]</span></p>
<p>In concrete cases, it is therefore impossible to examine all the
different possible alternative stratifications.</p>
<p>The <em>Genetic Algorithm</em> allows to explore the universe of
stratifications in a very efficient way in order to find the optimal (or
close to optimal) solution.</p>
<p>Choosing the <em>atomic</em> method, the application of the genetic
algorithm is based on the following steps:</p>
<ol style="list-style-type: decimal">
<li>the <em>atomic stratification</em> is built by cross-classifying the
units in the frame using all the values in the domains of definition of
all the stratification variables X, and aggregating units that have the
same combinations of values;</li>
<li>all alternative stratifications are produced by aggregating atomic
strata;</li>
<li>a given stratification is considered as an <em>individual</em> in a
population (= <em>generation</em>) subject to <em>evolution</em>;</li>
<li>each individual is characterized by a <em>genome</em> represented by
a vector of dimension equal to the number of atomic strata: the position
of each element in the vector identifies an atomic stratum;</li>
<li>each element in the vector is assigned a random value between 1 and
K (maximum acceptable number of strata): the vector therefore indicates
the way in which the individual atomic strata are aggregated
together;</li>
<li>for each individual (stratification) its <em>fitness</em> is
calculated by solving the corresponding problem of optimal allocation by
means of Bethel’s algorithm;</li>
<li>in passing from one generation to the next, <em>individuals with
higher fitness are favored</em>;</li>
<li>at the end of the process of evolution, the individual with the
overall best fitness represents the optimal solution.</li>
</ol>
<p>Instead, choosing the <em>continuous</em> or the <em>spatial</em>
method, steps are the following:</p>
<ol style="list-style-type: decimal">
<li>all alternative stratifications are produced by randomly generating
a number of cuts in the domains of definition of the continuous
stratification variables X;</li>
<li>a given stratification is considered as an <em>individual</em> in a
population (= <em>generation</em>) subject to <em>evolution</em>;</li>
<li>each individual is characterized by a <em>genome</em> represented by
a vector of dimension equal to the number of cuts product the number of
stratification variables X;</li>
<li>for each individual (stratification) its <em>fitness</em> is
calculated by solving the corresponding problem of optimal allocation by
means of Bethel’s algorithm;</li>
<li>in passing from one generation to the next, <em>individuals with
higher fitness are favored</em>;</li>
<li>at the end of the process of evolution, the individual with the
overall best fitness represents the optimal solution.</li>
</ol>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-baillargeon2014" class="csl-entry">
Baillargeon, Sophie, and Louis-Paul Rivest. 2014. <em>Stratification:
Univariate Stratification of Survey Populations</em>. <a href="https://CRAN.R-project.org/package=stratification" class="external-link">https://CRAN.R-project.org/package=stratification</a>.
</div>
<div id="ref-ballin2016" class="csl-entry">
Ballin, Marco, and Giulio Barcaroli. 2016. <span>“Optimization of
Stratified Sampling with the r Package <span>SamplingStrata</span>:
Applications to Network Data.”</span> <em>Computational Network Analysis
with R: Applications in Biology, Medicine and Chemistry</em>.
</div>
<div id="ref-ballin2013" class="csl-entry">
Ballin, M., and G. Barcaroli. 2013. <span>“Joint Determination of
Optimal Stratification and Sample Allocation Using Genetic
Algorithm.”</span> <em>Survey Methodology</em> 39: 369–93.
</div>
<div id="ref-barcarol2014" class="csl-entry">
Barcaroli, Giulio. 2014. <span>“SamplingStrata: An r Package for the
Optimization of Stratified Sampling.”</span> <em>Journal of Statistical
Software</em> 61 (4): 1–24. <a href="https://doi.org/10.18637/jss.v061.i04" class="external-link">https://doi.org/10.18637/jss.v061.i04</a>.
</div>
<div id="ref-bethel1989" class="csl-entry">
Bethel, J. 1989. <span>“Sample Allocation in Multivariate
Surveys.”</span> <em>Survey Methodology</em> 15: 47–57.
</div>
<div id="ref-hartigan:1979" class="csl-entry">
Hartigan, J. A., and M. A. Wong. 1979. <span>“A k-Means Clustering
Algorithm.”</span> <em>Applied Statistics</em> 28: 100–108.
</div>
<div id="ref-oluing2019" class="csl-entry">
O’Luing, M., S. Prestwich, and S. Armagan Tarim. 2019. <span>“A Grouping
Genetic Algorithm for Joint Stratification and Sample Allocation
Designs.”</span> <em>Survey Methodology</em> 45 (3): 513–31.
</div>
<div id="ref-willighagen2005" class="csl-entry">
Willighagen, E. 2005. <em>Genalg: R Based Genetic Algorithm</em>. <a href="https://CRAN.R-project.org/package=genalg" class="external-link">https://CRAN.R-project.org/package=genalg</a>.
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Giulio Barcaroli, Marco Ballin, Hanjo Odendaal, Daniela Pagliuca, Egon Willighagen, Diego Zardetto.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
